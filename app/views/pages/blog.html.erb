<div class="container">
  <div class="text-center">
  </div>
  <div class="hero-unit">
    <h3 id="title">Better Roommate Finder aka Rinder</h3>
    <h4 id="date">April 10th, 2014</h4>
    <p>I was chatting with a friend the other week and she was telling me horror stories of the girls she had been interviewing as potential roommates from Craigslist. Listening to her describe the insanity that had walked through her door I said that there had to be a better way to deal with this. As someone working in psychology she jumped in immediately saying “I know exactly what personality tests I would love to run to screen people”. This got me thinking, living with someone is a huge commitment, people test out significant others for years before moving in with them. Why do we not have a better system for finding a roommate? Tinder, OkCupid, and a multitude of other technologies allows everyone to screen dates easily and for free. For roommates people seem left with word of mouth (even if that is through a Facebook status) and Craigslist (which has some deep dark corners).</p>
    <p>I set out to discover what was out there, it seemed like there had to be something. What I found was extremely disappointing. I won’t name names, but all I saw were terrible UI/UXs which would never attract a sustainable population of twenty-somethings who are looking for roommates. I understand why craigslist is popular if your other social networks fail you, it is in the popular consciousness so it creates a large enough population of people to sustain the network. (Talk about network theory some here).</p>
    <p>From this research here are the things I think what I am now calling A Better Roommate Finder would need to have.</p>
    <ol>
	<li>It needs to include your current social networks. So when you post for a roommate you can send that same post as a Facebook Status, Tweet, etc. The application would then allow you to know when someone responded to that particular post. If we were ranking matches then those posts would be weighted as they come from your pre-built social network. Eventually if we got all up in data mining (which I love to do) you could weight the responses by the perceived value of your relationship with that person (through number of posts, messages, tweets, replies, etc)</li>

	<li>It has to be incredibly easy and intuitive to use (and free or at max freemium). (One way to then make money off this would be allowing apartment buildings to buy ads on this). Grinder/Tinder are popular because it takes minimal work to use. This application would probably have a little bit more to it (like OkCupid so that we can try to match you based on personality evaluations).</li>

	<li>Now more on those personality evaluations. There needs to be enough information, and it needs to be real information. Here is where my friends expertise would come in. There are a plethora of great psychological tools out there that I believe could be harnessed properly to help people find suitable roommates. Yes there will still be the exceptions to the rules and those that game the system, but I am speaking to the majority right now. We can do all the evaluations we want, but the key here will be interpreting that data into an easily digestible snippet (like the match, friend, enemy percentages shown on OkCupid)</li>
    </ol>
    <p>There are obviously a lot more things that would go into an application like this. I hope this is a project I can come back to eventually, but for now I just wanted to get down my thoughts.</p>
</div>
  <div class="hero-unit">
    <h3 id="title">What My CS Degree Really Taught Me</h3>
    <h4 id="date">April 4th, 2014</h4>
    <p>I have a Bachelor of Arts in Computer Science. The irony of that statement does not escape me. And the irony of moving from the heart of Silicon Valley to the land of "Colleges, Cows, Contentment" in Minnesota does not escape my parents. However, I could not be happier which my choice to study a more traditional engineering science in a liberal arts setting. If I hadn't gone to Carleton I might never have discovered CS and would probably have the History major I had planned on. To really explain this well I have to take you back to registering for my classes fall term of my Freshman year. I read the description for <a src"http://cs.carleton.edu/faculty/dlibenno/old/cs108-fall09/">"Life in the Age of Networks"</a> and thought is not only sounded really interesting, but also would be a way to get a Math and Science requirement out of the way without doing any actually math or science. Little did I know that this would lead down such a rabbit hole. 
    <p>My first CS class lead to another, and then to doing research on social networks that summer. Eventually, it lead to me learning as much as I could about different CS topics, exploring new languages, and currently spending my weekend and free time coding, since I am not doing that the majority of my time at work. I tried something new and in no way do I regret that, but I do miss coding and more importantly learning. Learning CS through a liberal arts lens allowed me to learn how to learn languages, techniques, algorithms, and so much more. During my Database Systems class instead of focusing on really complex SQL queries (although we did some of that), but instead focused on how to build out a strong and SOMETHING database structure. So I now both know how to write SQL queries to use the data and how to store it in the most effective way possible. Liberal Arts schools can be parodied for thier high-falutin notions and odd classes, however, the focus was on learning and how to learn. This has allowed me to expand my skill set whenever I have needed to learn a new language or technique and what I know will allow me to have a long career and keep up with new technologies. I hope someday to be that 80 year old who was on twitter before the teenagers.</p>
    <p>I do envy in certain ways those who had a more technical education that I did. They have skills that I will continue to need to catchup on and completly respect the way that they learned, I am just lucky enough to have found the way I learn the best and thrived in it.</p> 
  </div>

  <div class="hero-unit">
  <h3 id="title">Business Cards Are The Worst</h3>
  <h4 id="date">April 2nd, 2014</h4>
    <p id="body">I was handed a business card in a meeting not too long ago and looked at it during the meeting thinking well it is rude if I throw it away now, but it is only going to a) sit at my desk for months and evetually get thrown away b) get shoved into my purse to and sit there for months and eventually get thrown away c) get thrown away after this meeting. All roads led to me throwing away this card. I already had the person's contact info (we had exchanged e-mails before the meeting) and I don't currently use a business card digitizer app. I don't have one of those because I really only get business cardseither in very specific, random, and infrequent meetings or recently when all my friends graduated and got jobs and were eager to show them off. However, the fate of all those cards was the same. The trash can. Thinking through this problem I had a question why the heck isn't LinkedIn doing something about this?</p>
    <p> I saw them as the doui- head slapping forehead obvious solution to this problem. LinkedIn has already captured information on 250 million+ professionals. They are constantly capturing more and more data about how those people are connected and how the professional world grows, changes, lives, and breathes. They are the first stop for people to find a new job, meet someone in an industry, and keep up their professional network. Why shouldn't they tackle the problems of business cards in the 21st centrury? While there is a clear need for a solution the path to one is not as clear.</p>
   <p> Here are some of the problems I see and their possible solutions (with the assumption that LinkedIn in the platform for this solution)
	<ol>
	<li>Business cards often contain more infomation than you would want publically available on your profile. The solution would allow people to give certain contacts their "digital business card" after or during a meeting. This would allow that person access to supplemental profile information that normal connections do not have. This eliminates the extra steps a person has to go through when they get a business card (either digitizing through a 3rd party app, putting into their phones contacts, etc)</li>
	<li>For some people business cards are a visible reminder of the person and your interaction. This solution to this would be the email or push notification that accompanies sending someone your business card. While this reminder might be temporary so, in my opinion, is the reminder of a business card that gets thrown away.</li>
	<li>Other people scribble notes about the meeting, the date, time, and interaction that they then refer back to. The LinkedIn digital business card would allow for notes to be taken about your connection with someone. This a feature that already exists in LinkedIn Premium and would work very well with a ditigal business card feature.</li>
	<li> I like paper. Well then I can't help you there, feel free to rock those old school business cards then!</li>
	</ol>
    <p>Some of the features I have suggested are already available on LinkedIn Premium, but I think even adding a few little tweaks and marketing it so people begin to use LinkedIn for this purpose instead of business cards, rather than in addition to would be great. 
  </div>

  <div class="hero-unit">
  <h3 id="title">How Scheme finally taught me recursion</h3>
  <h4 id="date">March 3rd, 2014</h4>
  <p id="body">Recursion is one of those computer science topics that I, at least, just didn't get until I finally got it. I had different professors describe it (one even said he just thinks of it as "magic"), I read about it online, and I struggled with it in homework assignments. However, I really just didn't truely understand how it all worked until I had to write in Scheme for my programming languages class.</p>
  <p> Now it has been a while since I have used recursion, but I still remember the feeling of triumph when on one project in my Data Mining Class, I was beating my head against the wall we have all encountered a thousand times and it finally clicked. Instead of the 5 different, and incredibly inelegant ways I had been writing the function, one simple recusion call was all it took (see the code <a src="/python">here</a>). I can thank Scheme for this amazing relevation.</p>
  <p>Scheme is a functional language that is a dialect of Lisp. I learned it for Programming Languages my sophomore year of college in order to later write an interpreter for Scheme in C. Needless to say it was a long quarter, but I learned a ton. Not the least of which was how to actually write and understand recursion. Here is a binary search tree implementation I and a partner wrote in Scheme</p>
  <pre class="prettyprint">
  ;Binary Search Trees
  ;9/11/2011
  ;Alexandra Price and Morgan Jones

  ;Return an empty tree
  (define null-bst
    (lambda ()
      () ))

  ;Returns true if bst is empty, false otherwise
  (define null-bst? 
    (lambda (bst) 
      (if (null? bst) #t
       #f)))
  
  ;Returns the root of the bst
  (define entry
    (lambda (bst)
      (cond 
            ;returns #f if the bst does not have three items, the last two of which are lists
            ((not (= (length bst) 3)) #f)
            ((not(list? (car(cdr(cdr bst))))) #f)
            ((not(list? (car(cdr bst)))) #f)
            (else (car bst)))))

  ;Returns the left subtree of the bst
  (define left
    (lambda (bst)
      (cond
        ;returns #f if the bst does not have three items, the last two of which are lists
        ((not (= (length bst) 3)) #f)
            ((not(list? (car(cdr(cdr bst))))) #f)
            ((not(list? (car(cdr bst)))) #f)
            (else (car (cdr bst))))))

  ;Returns the right subtree of the bst
  (define right
    (lambda (bst)
      (cond
        ;returns #f if the bst does not have three items, the last two of which are lists
        ((not (= (length bst) 3)) #f)
            ((not(list? (car(cdr(cdr bst))))) #f)
            ((not(list? (car(cdr bst)))) #f)
            (else (car (cdr (cdr bst)))))))
    
  ;Creates a bst given the root and left and right subtrees
  (define make-bst
    (lambda (elt left right)
      ;check that the root is a number
      (if (not (number? elt)) #f)
      ;make sure the left and right subtrees are valid (either null or contain 3 items)
      (if (not (= (length left) 3))
          (if (not (null? left)) #f))
      (if (not (= (length right) 3))
          (if (not (null? right)) #f))
      ;check that the last two items of the left subtree (if it is not null) are lists
      (if (not (null? left))
          (begin
          (if (not(list? (car(cdr(cdr left))))) #f)
          (if (not(list? (car(cdr left)))) #f)))
      ;check that the last two items of the right subtree (if it is not null) are lists
      (if (not (null? right))
          (begin
          (if (not(list? (car(cdr(cdr right))))) #f)
          (if (not(list? (car(cdr right)))) #f)))
      ;if the input passes our extensive tests, create the tree
      (cons elt (cons left (list right)))))
    
 
  ;Returns a list containing all values from a preorder traversal
  (define preorder
    (lambda (bst)
      (if (null? bst) bst
            (append (list(car bst)) (preorder (left bst)) (preorder (right bst))))))

  ;Returns a list containing all values from an inorder traversal
  (define inorder
    (lambda (bst)
      (if (null? bst) bst
            (append (preorder (left bst))(list(car bst))(preorder (right bst))))))

  ;Returns a list containing all values from a postorder travesal
  (define postorder
      (lambda (bst)
        (if (null? bst) bst
            (append (preorder (left bst))(preorder (right bst))(list(car bst))))))

  ;Return a new bst with the new integer in the correct location
  (define insert
    (lambda (v bst)
      (if (null? bst) 
          (append (list v) '(()()))
          ;We find the right place for the new item while continually maintaining the original bst
          (cond
            ((= v (car bst)) bst)
            ((< v (car bst)) (cons (car bst) (cons (insert v (left bst))(list(right bst)))))
            ((> v (car bst)) (cons (car bst) (cons (left bst) (list(insert v (right bst))))))))))

  ;our testing:
  (null-bst)
  (null-bst? '(5))
  (entry '())
  (left '(5 (3) ()))
  (right '(5 (3) ()))
  (left '(5(3()())(4()())))
  (make-bst 5 '() '(6 () ()))
  (postorder '(5 (3 (4 () ())()) (6 () (7 () ()))))
  (insert 3 '(5 (3 () ()) (7 () ())))
  </pre>
  <p>Since Scheme is a functional language that esstentially means that everything you do has to be recursive. This meant no work arounds, no half-assing it, just straight up recursion. Now the best way I know to explain recursion is somewhat of a conglomoration of the explinations I have digested over the years. Recursion works when smaller and smaller instances of a problem are solved building back up to solve the original problem. </p>

  <p>Now I'm not saying that learning Scheme is the way to learn recursion, but it certainly cleared up the magic of recursion worked for me.</p>
  </div>

</div>


